---
title: "ConnectomeDB Stats"
execute:
  echo: false
  warnings: false  # Add this line to suppress warnings globally
toc: false
---

## The Charts below are Interactive. Unselect the categories you are not interested and watch the charts change!

::: {.columns}

::: {.column width="50%"}

### Based on the [**Human LR pairs Database**](database/human.qmd)

::: {.panel-tabset}

```{python}
#| echo: false
import sys
import os
import re
import pandas as pd
import plotly.express as px
sys.path.append(os.path.abspath("src"))
from createDataTable import gene_pair
from createTriplicateDT import gene_pair_trip
from createFunctionalAnnotTable import gene_pair_disease, gene_pair_pathway, gene_pair_annot_ligand, gene_pair_annot_receptor

# Parameters
# color for unknown
gray_color = "#d1cdcd"
yes_color = "#dbbd27"
no_color = "navy"

# Subset categorical columns
gene_pair_cat = gene_pair.iloc[:, [2, 7, 8, 9, 10, 13, 14]]
cat_cols = gene_pair_cat.select_dtypes(include='object').columns

figs = []

for col in cat_cols:
    # Clean values: remove HTML tags
    cleaned_values = gene_pair_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))
    # Replace commas with newlines in a display-safe version of the values
    cleaned_values = cleaned_values.apply(lambda x: x.replace('secreted by ischemic cardiomyocytes, secreted by necrotic cells', 'secreted by ischemic cardiomyocytes & necrotic cells'))
    cleaned_values = cleaned_values.apply(lambda x: x.replace('Endoplasmic reticulum', 'ER'))
    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    # Add (n=...) to each label
    counts['label'] = counts.apply(
        lambda row: f"{row['count']} {row[col]}" if row[col] == "unknown" else f"{row[col]} (n={row['count']})", axis=1)   
    
    # Sort labels alphabetically
    counts = counts.sort_values("label")
    
    # Capture the sorted labels
    sorted_labels = counts['label'].tolist()
    
    # Define the color map
    # Color map: only specify "unknown", "yes", "no"
    color_map = {}
    for name in counts['label']:
        lower_name = name.lower()
        if lower_name.startswith("yes"):
            color_map[name] = yes_color
        elif lower_name.startswith("no"):
            color_map[name] = no_color
        elif "unknown" in lower_name:
            color_map[name] = gray_color  # your custom gray
    
    cat_count = str(cleaned_values.nunique())
    fig = px.pie(
        counts,
        names='label',
        values='count',
        hole=0.4,
        title=f"Distribution of {cat_count} {col}",
        color='label',
        color_discrete_map=color_map,
        category_orders={'label': sorted_labels}  # Force legend order
    )

    fig.update_traces(textinfo='percent+label',
                      hovertemplate="%{label}<extra></extra>",
                      textposition='inside')
    fig.update_layout(
    legend_title_text=col,
    legend=dict(
        orientation="v",
        y=0.5,
        yanchor="middle",
        x=1.05,
        xanchor="left"
    ),
    width=600,
    height=300
)
   
    figs.append(fig)

```

## Binding Location

```{python}
#| echo: false
figs[1]
```

## Bind in Trans

```{python}
#| echo: false
figs[2]
```

## Bidirectional

```{python}
#| echo: false
figs[3]
```

## Interaction Type

```{python}
#| echo: false
figs[4]
```


## Ligand Location

```{python}
#| echo: false
figs[5]
```


## Receptor Location

```{python}
#| echo: false
figs[6]
```

:::

:::

::: {.column width="50%"}

### Based on the [**Human LR Pair Ë£ Pubmed Evidence**](database/human-trip.qmd)

::: {.panel-tabset}

## PMID count by Year 

```{python}
#| echo: false
# Select categorical columns
gene_pair_trip_cat = gene_pair_trip.iloc[:, [3,6,10]]
cat_cols_trip = gene_pair_trip_cat.select_dtypes(include='object').columns

year_col = gene_pair_trip['Year']

# Convert datetime64 to int nanoseconds since epoch
ns_int = year_col.astype('int64')

# Extract last 5 digits (to get a usable year approximation)
years = ns_int % (10**5)

# Count frequencies by year
year_counts = pd.Series(years).value_counts().sort_index().reset_index()
year_counts.columns = ['Year', 'Count']

```

```{python}
#| echo: false
# Create bar plot
fig = px.bar(
    year_counts,
    x='Year',
    y='Count',
    title='PMID counts per Year',
    labels={'Year': 'Year', 'Count': 'Count'},
    template='plotly_white'
)
fig.update_layout(xaxis_tickangle=-45, width=600, height=300)



```

```{python}
#| echo: false

figs_trip = []
for col in cat_cols_trip:
    # Clean values: remove HTML tags
    cleaned_values = gene_pair_trip_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))

    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    counts['label'] = counts.apply(lambda row: f"{row[col]} (n={row['count']})", axis=1)
    # Add (n=...) to each label
    counts['label'] = counts.apply(
        lambda row: f"{row['count']} {row[col]}" if row[col] == "unknown" else f"{row[col]} (n={row['count']})", axis=1)   
    
    # Sort labels alphabetically
    counts = counts.sort_values("label")
    
    # Capture the sorted labels
    sorted_labels = counts['label'].tolist()
    # Color map: only specify "unknown", "yes", "no"
    color_map = {}
    for name in counts['label']:
        lower_name = name.lower()
        if lower_name.startswith("yes"):
            color_map[name] = yes_color
        elif lower_name.startswith("no"):
            color_map[name] = no_color
        elif "unknown" in lower_name:
            color_map[name] = gray_color  # your custom gray

    cat_count = str(cleaned_values.nunique())

    fig_trip = px.pie(
        counts,
        names='label',  # Use custom label with (n=...)
        values='count',
        hole=0.4,
        title=f"Distribution of {cat_count} {col}",
        color='label',  # Use label column for color mapping
        color_discrete_map=color_map,
        category_orders={'label': sorted_labels}  # Force legend order
    )
    fig_trip.update_traces(textinfo='percent+label', 
                           textposition='inside',
                           hovertemplate="%{label}<extra></extra>")
    fig_trip.update_layout(
    legend_title_text=col,
    legend=dict(
        orientation="v",
        y=0.5,
        yanchor="middle",
        x=1.05,
        xanchor="left"
    ),
    width=600,
    height=300
)
    figs_trip.append(fig_trip)

```

## Database Source

```{python}
#| echo: false
figs_trip[0]

```


## Journal

```{python}
#| echo: false
figs_trip[1]
```

## Species

```{python}
#| echo: false
figs_trip[2]
```


## Temp1

```{python}
#| echo: false
figs_trip[2]
```

## Temp2

```{python}
#| echo: false
figs_trip[2]
```

## Temp3

```{python}
#| echo: false
figs_trip[2]
```
:::

:::

:::



::: {.columns}

::: {.column width="100%"}

### LR pair count Based on the [**Disease Annotations**](annotations/disease.qmd)

::: {.panel-tabset}

```{python}
#| echo: false

# Subset categorical columns
disease_cat = gene_pair_disease.iloc[:, [2, 3, 4]]
cat_cols = disease_cat.select_dtypes(include='object').columns

figs_disease = []

for col in cat_cols:
    # Clean values: remove HTML tags
    cleaned_values = disease_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))

    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    # Add (n=...) to each label
    counts['label'] = counts.apply(
        lambda row: f"{row['count']} {row[col]}" if row[col] == "unknown" else f"{row[col]} (n={row['count']})", axis=1)   
    
    # Sort labels alphabetically
    counts = counts.sort_values("label")
    
    # Capture the sorted labels
    sorted_labels = counts['label'].tolist()
    # Color map: only specify "unknown", "yes", "no"
    color_map = {}
    for name in counts['label']:
        lower_name = name.lower()
        if lower_name.startswith("yes"):
            color_map[name] = yes_color
        elif lower_name.startswith("no"):
            color_map[name] = no_color
        elif "unknown" in lower_name:
            color_map[name] = gray_color  # your custom gray

    cat_count = str(cleaned_values.nunique())
    fig_disease = px.pie(
        counts,
        names='label',  # Use custom label with (n=...)
        values='count',
        hole=0.4,
        title=f"Distribution of {cat_count} {col}",
        color='label',  # Use label column for color mapping
        color_discrete_map=color_map,
        category_orders={'label': sorted_labels}  # Force legend order
    )
    fig_disease.update_traces(textinfo='percent+label', 
                              textposition='inside',
                              hovertemplate="%{label}<extra></extra>")
    fig_disease.update_layout(
    legend_title_text=col,
    legend=dict(
        orientation="v",
        y=0.5,
        yanchor="middle",
        x=1.05,
        xanchor="left"
    ),
    width=1200,
    height=300
)
    figs_disease.append(fig_disease)

```

## Specific Disease

```{python}

#| echo: false
figs_disease[0]

```

## Disease Type

```{python}

#| echo: false
figs_disease[1]

```

## Cancer-related

```{python}

#| echo: false
figs_disease[2]

```


:::

:::

::: {.column width="100%"}

### LR pair count Based on the [**Pathway Annotations**](annotations/pathway.qmd)

::: {.panel-tabset}

```{python}
#| echo: false
# Select categorical columns
cat_pathways = gene_pair_pathway.iloc[:, [3,4,5]]
cat_cols_trip = cat_pathways.select_dtypes(include='object').columns

figs_pathway = []
for col in cat_cols_trip:
    # Clean values: remove HTML tags
    cleaned_values = cat_pathways[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))
    
    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    counts['label'] = counts.apply(lambda row: f"{row[col]} (n={row['count']})", axis=1)
    # Add (n=...) to each label
    counts['label'] = counts.apply(
        lambda row: f"{row['count']} {row[col]}" if row[col] == "unknown" else f"{row[col]} (n={row['count']})", axis=1)   
    
    # Sort labels alphabetically
    counts = counts.sort_values("label")
    
    # Capture the sorted labels
    sorted_labels = counts['label'].tolist()
    # Color map: only specify "unknown"
    # Color map: only specify "unknown", "yes", "no"
    color_map = {}
    for name in counts['label']:
        lower_name = name.lower()
        if lower_name.startswith("yes"):
            color_map[name] = yes_color
        elif lower_name.startswith("no"):
            color_map[name] = no_color
        elif "unknown" in lower_name:
            color_map[name] = gray_color  # your custom gray
    cat_count = str(cleaned_values.nunique())

    fig_pathway = px.pie(
        counts,
        names='label',  # Use custom label with (n=...)
        values='count',
        hole=0.4,
        title=f"Distribution of {cat_count} {col}",
        color='label',  # Use label column for color mapping
        color_discrete_map=color_map,
        category_orders={'label': sorted_labels}  # Force legend order
    )
    fig_pathway.update_traces(textinfo='percent+label', textposition='inside')
    fig_pathway.update_layout(
    legend_title_text=col,
    legend=dict(
        orientation="v",
        y=0.5,
        yanchor="middle",
        x=1.05,
        xanchor="left"
    ),
    width=1200,
    height=300
)
    figs_pathway.append(fig_pathway)

```

## KEGG Pathway

```{python}
#| echo: false
figs_pathway[0]

```

## KEGG relationship

```{python}
#| echo: false
figs_pathway[1]

```

## PROGENy Pathway

```{python}
#| echo: false
figs_pathway[2]

```
:::

:::

:::


::: {.columns}

::: {.column width="50%"}

### Gene count based on the [**Ligand**](annotations/ligand_group.qmd) Annotations

::: {.panel-tabset}

```{python}
#| echo: false

# Get top N categories
top_n = 50 
height = 800
width = 600

# Subset categorical columns
lig_cat = gene_pair_annot_ligand.iloc[:, [3,2]]
cat_cols = lig_cat.select_dtypes(include='object').columns

import plotly.graph_objects as go

figs_lig = []

for col in cat_cols:
    # Clean values: remove HTML tags
    cleaned_values = lig_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))

    # Count category frequencies
    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    cat_count = str(cleaned_values.nunique())

    top_counts = counts.sort_values('count', ascending=False).head(top_n)
    
    # Reverse order to show highest count at the top
    top_counts = top_counts.iloc[::-1]

    # Assign bar colors: gray for 'unknown', default blue for others
    bar_colors = top_counts[col].apply(
        lambda val: gray_color if "unknown" in val.lower() else "#1f77b4"
    )

    # Create base bar plot
    fig_lig = go.Figure()

    fig_lig.add_trace(go.Bar(
        x=top_counts['count'],
        y=top_counts[col],
        orientation='h',
        marker_color=bar_colors,
        hoverinfo='x+y'
    ))

    # Add annotations: "n={count}" at end of each bar
    for i, row in top_counts.iterrows():
        fig_lig.add_annotation(
            x=row['count'],
            y=row[col],
            text=f"n={row['count']}",
            showarrow=False,
            xanchor="left",
            yanchor="middle",
            font=dict(size=11),
            xshift=5  # spacing from the bar tip
        )

    # Update layout
    fig_lig.update_layout(
        title=f"Top {top_n} of {cat_count} "
              f"{col.rstrip() if col.rstrip().endswith('s') else col.rstrip() + 's'}",
        yaxis=dict(
            tickangle=0,
            tickfont=dict(size=11)
        ),
        yaxis_title=col,
        xaxis_title="Count",
        margin=dict(l=100, r=20, t=60, b=20),
        width=width,
        height=height,
        showlegend=False
    )

    figs_lig.append(fig_lig)


figs_lig2 = []

for col in cat_cols:
    # Clean values: remove HTML tags
    cleaned_values = lig_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))
    # Replace commas with newlines in a display-safe version of the values
    cleaned_values = cleaned_values.apply(lambda x: x.replace('secreted by ischemic cardiomyocytes, secreted by necrotic cells', 'secreted by ischemic cardiomyocytes & necrotic cells'))
    cleaned_values = cleaned_values.apply(lambda x: x.replace('Endoplasmic reticulum', 'ER'))
    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    # Add (n=...) to each label
    counts['label'] = counts.apply(
        lambda row: f"{row['count']} {row[col]}" if row[col] == "unknown" else f"{row[col]} (n={row['count']})", axis=1)   
    
    # Sort labels alphabetically
    counts = counts.sort_values("label")
    
    # Capture the sorted labels
    sorted_labels = counts['label'].tolist() 
    # Color map: only specify "unknown", "yes", "no"
    color_map = {}
    for name in counts['label']:
        lower_name = name.lower()
        if lower_name.startswith("yes"):
            color_map[name] = yes_color
        elif lower_name.startswith("no"):
            color_map[name] = no_color
        elif "unknown" in lower_name:
            color_map[name] = gray_color  # your custom gray

    cat_count = str(cleaned_values.nunique())
    fig_lig2 = px.pie(
        counts,
        names='label',  # Use custom label with (n=...)
        values='count',
        hole=0.4,
        title=f"Distribution of {cat_count} {col}",
        color='label',  # Use label column for color mapping
        color_discrete_map=color_map,
        category_orders={'label': sorted_labels}  # Force legend order
    )
    fig_lig2.update_traces(textinfo='percent+label', 
                           textposition='inside',
                           hovertemplate="%{label}<extra></extra>")
    fig_lig2.update_layout(
    legend_title_text=col,
    legend=dict(
        orientation="v",
        y=-0.5,
        yanchor="bottom",
        x=1.05,
        xanchor="center"
    ),
    width=width,
    height=height
)
   
    figs_lig2.append(fig_lig2)


```

## Ligand Lineage

```{python}

#| echo: false
figs_lig[0]

```


## Ligand location

```{python}

#| echo: false
figs_lig2[1]

```



:::

:::

::: {.column width="50%"}

### Gene count based on the [**Receptor**](annotations/receptor_group.qmd) Annotations


::: {.panel-tabset}

## Receptor Lineage

```{python}
#| echo: false
# Select categorical columns
# Subset categorical columns
rec_cat = gene_pair_annot_receptor.iloc[:, [3,2]]
cat_cols = rec_cat.select_dtypes(include='object').columns

# Get top N categories
top_n = 50 
height = 800
width = 600


figs_rec = []

for col in cat_cols:
    # Clean values: remove HTML tags
    cleaned_values = rec_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))

    # Count category frequencies
    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    cat_count = str(cleaned_values.nunique())

    top_counts = counts.sort_values('count', ascending=False).head(top_n)
    
    # Reverse order to show highest count at the top
    top_counts = top_counts.iloc[::-1]

    # Assign bar colors: gray for 'unknown', default blue for others
    bar_colors = top_counts[col].apply(
        lambda val: gray_color if "unknown" in val.lower() else "#1f77b4"
    )

    # Create base bar plot
    fig_rec = go.Figure()

    fig_rec.add_trace(go.Bar(
        x=top_counts['count'],
        y=top_counts[col],
        orientation='h',
        marker_color=bar_colors,
        hoverinfo='x+y'
    ))

    # Add annotations: "n={count}" at end of each bar
    for i, row in top_counts.iterrows():
        fig_rec.add_annotation(
            x=row['count'],
            y=row[col],
            text=f"n={row['count']}",
            showarrow=False,
            xanchor="left",
            yanchor="middle",
            font=dict(size=11),
            xshift=5  # spacing from the bar tip
        )

    # Update layout
    fig_rec.update_layout(
        title=f"Top {top_n} of {cat_count} "
              f"{col.rstrip() if col.rstrip().endswith('s') else col.rstrip() + 's'}",
        yaxis=dict(
            tickangle=0,
            tickfont=dict(size=10)
        ),
        yaxis_title=col,
        xaxis_title="Count",
        margin=dict(l=100, r=20, t=60, b=20),
        width=width,
        height=height,
        showlegend=False
    )
    figs_rec.append(fig_rec)

figs_rec2 = []

for col in cat_cols:
    # Clean values: remove HTML tags
    cleaned_values = rec_cat[col].astype(str).apply(lambda x: re.sub(r'<.*?>', '', x))
    counts = cleaned_values.value_counts().reset_index()
    counts.columns = [col, 'count']
    # Add (n=...) to each label
    counts['label'] = counts.apply(
        lambda row: f"{row['count']} {row[col]}" if row[col] == "unknown" else f"{row[col]} (n={row['count']})", axis=1)   
    
    # Sort labels alphabetically
    counts = counts.sort_values("label")
    
    # Capture the sorted labels
    sorted_labels = counts['label'].tolist()
    # Color map: only specify "unknown", "yes", "no"
    color_map = {}
    for name in counts['label']:
        lower_name = name.lower()
        if lower_name.startswith("yes"):
            color_map[name] = yes_color
        elif lower_name.startswith("no"):
            color_map[name] = no_color
        elif "unknown" in lower_name:
            color_map[name] = gray_color  # your custom gray

    cat_count = str(cleaned_values.nunique())
    fig_rec2 = px.pie(
        counts,
        names='label',  # Use custom label with (n=...)
        values='count',
        hole=0.4,
        title=f"Distribution of {cat_count} {col}",
        color='label',  # Use label column for color mapping
        color_discrete_map=color_map,
        category_orders={'label': sorted_labels}  # Force legend order
    )
    fig_rec2.update_traces(textinfo='percent+label', textposition='inside')
    fig_rec2.update_layout(
    legend_title_text=col,
    legend=dict(
        orientation="v",
        y=0.5,
        yanchor="middle",
        x=1.05,
        xanchor="left"
    ),
    width=width,
    height=height
)
   
    figs_rec2.append(fig_rec2)


```

```{python}
#| echo: false
figs_rec[0]

```
## Receptor location

```{python}
#| echo: false
figs_rec2[1]

```

:::

:::

