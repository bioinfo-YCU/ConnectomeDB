---
title: "Browse Files"
format: html
execute:
  echo: false
---

```{python}
#| echo: false
#| output: asis
import os
import sys
from pathlib import Path
from datetime import datetime
import humanize
import mimetypes
from urllib.parse import parse_qs, urlparse, unquote, quote
import logging

# --- LOGGING SETUP ---
LOG_FILE = Path(os.getcwd()) / "browse_debug.log"
logging.basicConfig(
    filename=LOG_FILE,
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
def debug_log(message):
    logging.info(message)
# --- END LOGGING SETUP ---

def load_config():
    """Load repository configuration"""
    config_file = Path("JSON/config.json")
    if config_file.exists():
        with open(config_file, 'r') as f:
            return json.load(f)
    return {
        "title": "ConnectomeDB Data Repository",
        "description": "Browse and download Ligand-receptor database tables across 14 most studied species.",
        "license": "MIT License",
        "contact":  "mailto:&#104;&#101;&#108;&#112;&#64;&#99;&#111;&#110;&#110;&#101;&#99;&#116;&#111;&#109;&#101;&#100;&#98;&#46;&#111;&#114;&#103;,&#97;&#108;&#105;&#115;&#116;&#97;&#105;&#114;&#46;&#102;&#111;&#114;&#114;&#101;&#115;&#116;&#64;&#112;&#101;&#114;&#107;&#105;&#110;&#115;&#46;&#117;&#119;&#97;&#46;&#101;&#100;&#117;&#46;&#97;&#117;",
        "citation": "[ConnectomeDB2025, a high quality manually curated ligand-receptor database for cell-to-cell communication prediction](), P Liu, S Maezono et al. *Journal Title* **XX (YY)**, ZZZ (2025). DOI: 10.xxxx/xxxxx"
    }

# Load configuration and directory info
config = load_config()

def get_query_params():
    query_string = ""
    env_query_string = os.getenv("QUARTO_PROJECT_URL_QUERY", "")
    if env_query_string:
        debug_log(f"Detected query_string from QUARTO_PROJECT_URL_QUERY: {env_query_string}")
        query_string = env_query_string
    
    if not query_string and len(sys.argv) > 1 and sys.argv[1] != '-f':
        full_url_from_argv = sys.argv[1]
        debug_log(f"Detected full_url from sys.argv[1]: {full_url_from_argv}")
        parsed_url = urlparse(full_url_from_argv)
        query_string = parsed_url.query
    elif len(sys.argv) > 1 and sys.argv[1] == '-f':
        debug_log("sys.argv[1] detected as '-f', skipping for URL parsing.")

    if not query_string:
        cgi_query_string = os.getenv("QUERY_STRING", "")
        if cgi_query_string:
            debug_log(f"Detected query_string from QUERY_STRING env var: {cgi_query_string}")
            query_string = cgi_query_string
        else:
            debug_log("No query string found in QUARTO_PROJECT_URL_QUERY, sys.argv[1], or QUERY_STRING env var.")
    
    parsed_params = parse_qs(query_string)
    if 'dir' in parsed_params and parsed_params['dir']:
        parsed_params['dir'][0] = unquote(parsed_params['dir'][0])
    
    debug_log(f"Final parsed query parameters: {parsed_params}")
    return parsed_params

def is_visible(p):
    # Exclude dotfiles, .qmd, .ipynb (and .quarto_ipynb if it's an intermediate file)
    if p.name.startswith('.'):
        return False
    if p.suffix.lower() in ['.qmd', '.ipynb', '.quarto_ipynb']: # Added suffixes to exclude
        return False
    return True

def get_file_info(file_path: Path):
    stat = file_path.stat()
    mime_type, _ = mimetypes.guess_type(str(file_path))
    return {
        "name": file_path.name,
        "size": humanize.naturalsize(stat.st_size),
        "size_bytes": stat.st_size,
        "modified": datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d"),
        "type": mime_type or "application/octet-stream",
        "extension": file_path.suffix.lower(),
        # Make the path relative to the project root for downloads
        "path": str(file_path.relative_to(Path(os.getcwd()))) 
    }

def get_file_description(filename):
    name_lower = filename.lower()
    if 'human' in name_lower: return "Homo sapiens"
    elif 'mouse' in name_lower: return "Mus musculus"
    elif 'chimp' in name_lower: return "Pan troglodytes"
    elif 'chicken' in name_lower: return "Gallus gallus"
    elif 'pig' in name_lower: return "Sus scrofa"
    elif 'rat' in name_lower: return "Rattus norvegicus"
    elif 'cow' in name_lower: return "Bos taurus"
    elif 'dog' in name_lower: return "Canis lupus familiaris"
    elif 'horse' in name_lower: return "Equus caballus"
    elif 'sheep' in name_lower: return "Ovies aries rambouillet"
    elif 'marmoset' in name_lower: return "Callithrix jacchus"
    elif 'macaque' in name_lower: return "Macaca mulatta"
    elif 'frog' in name_lower: return "Xenopus tropicalis"
    elif 'zebrafish' in name_lower: return "Danio rerio"
    elif name_lower.endswith('.zip'): return "mixed"
    else: return ""

def get_directory_description(dirname):
    """Get a descriptive label for directory names"""
    name_lower = dirname.lower()
    if name_lower == 'csv': 
        return "Comma-separated values"
    elif name_lower == 'tsv': 
        return "Tab-separated values"
    elif name_lower == 'json': 
        return "JavaScript Object Notation"
    elif name_lower == 'xml': 
        return "eXtensible Markup Language"
    elif name_lower == 'excel' or name_lower == 'xlsx': 
        return "Excel spreadsheets"
    elif name_lower == 'txt' or name_lower == 'text': 
        return "Plain text files"
    elif name_lower == 'pdf': 
        return "Portable Document Format"
    elif name_lower == 'images' or name_lower == 'img': 
        return "Image files"
    elif name_lower == 'docs' or name_lower == 'documents': 
        return "Document files"
    elif name_lower == 'data': 
        return "Data files"
    elif name_lower == 'archive' or name_lower == 'archives': 
        return "Archive files"
    elif name_lower == 'current-release': 
        return "Current release files"
    elif name_lower == 'previous-release': 
        return "Previous release files"
    else: 
        return "Subdirectory"

def browse_directory(dir_path, base_path="downloads"):
    debug_log(f"browse_directory called with dir_path='{dir_path}', base_path='{base_path}'")
    
    current_working_dir = Path(os.getcwd())
    debug_log(f"Current OS working directory: {current_working_dir}")
    debug_log(f"Is 'downloads' directory visible from CWD? {Path('downloads').is_dir()}")

    absolute_base_path = current_working_dir / base_path
    debug_log(f"Absolute base path for downloads: {absolute_base_path}")
    debug_log(f"Does absolute_base_path exist? {absolute_base_path.exists()}")
    debug_log(f"Is absolute_base_path a directory? {absolute_base_path.is_dir()}")

    target_path = Path(absolute_base_path)

    if dir_path and dir_path.strip() != "":
        normalized_dir_path = dir_path.replace('\\', '/')
        target_path = absolute_base_path / normalized_dir_path
    
    debug_log(f"Constructed target_path: {target_path}")
    debug_log(f"Does target_path exist? {target_path.exists()}")
    debug_log(f"Is target_path a directory? {target_path.is_dir()}")

    if not target_path.exists():
        debug_log(f"Error: target_path '{target_path}' does NOT exist.")
        return None, f"Directory '{dir_path}' not found. Resolved path: '{target_path}'"
    
    if not target_path.is_dir():
        debug_log(f"Error: target_path '{target_path}' is NOT a directory.")
        return None, f"Path '{dir_path}' exists but is not a directory. Resolved path: '{target_path}'"

    files = []
    subdirs = []

    try:
        debug_log(f"Attempting to list contents of: {target_path}")
        for item in sorted(target_path.iterdir()):
            debug_log(f"Found item: {item.name}, is_dir: {item.is_dir()}, is_file: {item.is_file()}")
            if not is_visible(item):
                debug_log(f"Skipping hidden item: {item.name}")
                continue
            
            if item.is_file():
                files.append(get_file_info(item))
            elif item.is_dir():
                visible_files = []
                try:
                    for subitem in item.rglob("*"):
                        if subitem.is_file() and is_visible(subitem):
                            visible_files.append(subitem)
                except Exception as e:
                    debug_log(f"Error reading subdirectory {item.name}: {e}")
                    continue
                
                # --- CRITICAL CHANGE FOR NESTED .QMDs ---
                # Subdirectory links will now point to their respective index.html
                # Example: Current-Release/CSV -> Current-Release/CSV/index.html
                
                # Construct the path relative to the *project root* for the Quarto output
                # The generated HTML will be at downloads/Current-Release/CSV/index.html
                if dir_path:
                    # If we are already in a subdirectory (e.g., 'Current-Release'),
                    # the link should be `downloads/Current-Release/CSV/index.html`
                    subdir_link_target = Path("downloads") / Path(dir_path) / item.name / "index.html"
                else:
                    # If we are at the top level (e.g., initial load of browse.html with no 'dir' param,
                    # defaulting to 'Current-Release'), the link should be `downloads/Current-Release/index.html`
                    subdir_link_target = Path("downloads") / item.name / "index.html"

                subdir_info = {
                    "name": item.name,
                    "link": str(subdir_link_target).replace("\\", "/"), # URL needs forward slashes
                    "file_count": len(visible_files),
                    "description": get_directory_description(item.name)
                }
                subdirs.append(subdir_info)

    except PermissionError as e:
        debug_log(f"Permission Error when listing directory {target_path}: {e}")
        return None, f"Permission denied to access directory '{dir_path}'. Error: {e}"
    except Exception as e:
        debug_log(f"Unexpected error when listing directory {target_path}: {e}")
        return None, f"An unexpected error occurred browsing '{dir_path}'. Error: {e}"

    return {
        "name": target_path.name,
        "path": str(target_path),
        "relative_path": dir_path,
        "files": files,
        "subdirs": subdirs,
        "total_files": len(files),
        "total_size": sum(f["size_bytes"] for f in files) if files else 0
    }, None

def get_breadcrumb_path(dir_path):
    if not dir_path or dir_path.strip() == "":
        return "[← Back to Downloads](downloads.html)"
    
    dir_path = dir_path.replace('\\', '/')
    parts = dir_path.split('/')
    breadcrumbs = ["[← Back to Downloads](downloads.html)"]
    
    current_path_segments = []
    for i, part in enumerate(parts):
        current_path_segments.append(part)
        
        # If this is the last part, it's the current directory and should point to its own index.html
        # Otherwise, if it's an intermediate directory (like 'Current-Release' for 'Current-Release/CSV')
        # it should point to its browse.html entry or its index.html if it exists.
        
        # For top-level browse pages, link to browse.html.
        # For deeper nested subdirs, we'll link to their respective index.html (handled below)
        
        # This part of the breadcrumb will always point to browse.html for consistency at the top level
        link_target = f"browse.html?dir={quote('/'.join(current_path_segments))}"
        
        breadcrumbs.append(f"[{part}]({link_target})")
    
    return " / ".join(breadcrumbs)


# --- Main Execution Logic ---
debug_log("Starting script execution.")
params = get_query_params()
current_dir = params.get('dir', [None])[0]

if not current_dir:
    debug_log("No 'dir' parameter found, defaulting to 'Current-Release'")
    current_dir = 'Current-Release'
else:
    debug_log(f"'dir' parameter found: '{current_dir}'")

dir_info, error = browse_directory(current_dir)

if error:
    debug_log(f"Error encountered: {error}")
    print(f"""
## Error

{error}

**Requested path:** `{current_dir}`

[← Back to Downloads](downloads.html)
""")
else:
    debug_log(f"Successfully browsed directory: {dir_info['name']} at {dir_info['path']}")
    # Adjusted breadcrumb to ensure it links to browse.html for top levels
    breadcrumb = f"[← Back to Downloads](downloads.html) / [{dir_info['name']}](browse.html?dir={quote(current_dir)})"
    if '/' in current_dir: # For nested paths, generate breadcrumb properly
        breadcrumb = get_breadcrumb_path(current_dir)

    print(f"""
## Directory: {dir_info['name']}
All ConnectomeDB ligand–receptor interaction data are freely available under the MIT License and are provided AS IS, without any warranty. Please use the file navigator below to browse and download the most up-to-date database tables. For previous data releases, please click [here](under_construction.qmd).

{breadcrumb}

---
""")

    custom_order = ["all", "human", "mouse", "chimp", "macaque", "marmoset", "rat", "pig", "cow", "dog", "horse", "sheep", "chicken", "frog", "zebrafish"]
    def get_sort_priority(filename):
        name_lower = filename.lower()
        for i, keyword in enumerate(custom_order):
            if keyword in name_lower: return i
        return len(custom_order)

    sorted_files = sorted(dir_info['files'], key=lambda f: get_sort_priority(f['name']))

    if dir_info['subdirs']:
        print("### Subdirectories\n")
        print("| Directory | Files | Description |")
        print("|-----------|-------|-------------|")
        for subdir in dir_info['subdirs']:
            # Use subdir['link'] which is now pointing to index.html in the subfolder
            subdir_link = f"[{subdir['name']}]({subdir['link']})"
            file_count_text = f"{subdir['file_count']} files" if subdir['file_count'] > 0 else "Empty"
            print(f"| {subdir_link} | {file_count_text} | {subdir['description']} |")
        print("\n---\n")

    if sorted_files:
        print("### Files\n")
        print("| Filename | Size | Modified | Type | Species |")
        print("|----------|------|----------|------|-------------|")
        for file_info in sorted_files:
            download_link = f"<a href='{file_info['path']}' download>{file_info['name']}</a>"
            id_value = file_info['name'].replace('.', '_').replace('-', '_')
            description = get_file_description(file_info['name'])
            file_type = file_info['extension'].upper().replace('.', '') if file_info['extension'] else 'FILE'
            print(f"| {download_link} | {file_info['size']} | {file_info['modified']} | {file_type} | {description} |")
        print("\n<div id='file-details'></div>\n")
    else:
        print("### No files found in this directory\n")
        
    if dir_info['subdirs']:
        total_subdir_files = sum(subdir['file_count'] for subdir in dir_info['subdirs'])
    
    print(f"""
        ---
        If you have any questions, please feel free to [contact us]({config['contact']}). If you are using ConnectomeDB, please cite us: {config['citation']}
        """)
```